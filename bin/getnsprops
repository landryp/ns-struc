#!/usr/bin/python
__doc__ = 'GETNSPROPS -- calculate NS properties as a function of central density for selected EoSs'
__usage__ = 'getnsprops EoS1.csv,EoS2.csv,... [-v] [-p R,M,Lambda,...] [-n 200] [-r 0.8,12] [-d ./eos/] [-o ./dat/]'
__author__ = 'philippe.landry@ligo.org'
__date__ = '03-2019'

import numpy as np
import os
from optparse import OptionParser
import scipy
from scipy.interpolate import interp1d
from nsstruc.tov import tov
from nsstruc.constants import *
from nsstruc.pltsetup import *

assert(float((np.version.version).split('.')[0]) >= 1. and float((np.version.version).split('.')[1]) >= 14.)

assert(float((scipy.version.version).split('.')[0]) >= 1. and float((scipy.version.version).split('.')[1]) >= 0.)

parser = OptionParser(usage=__usage__, description=__doc__)
parser.add_option('-p', '--props', default='R,M,Lambda', help='comma-separated list of NS properties to calculate, DEFAULT=R,M,Lambda', metavar='R,M,Lambda')
parser.add_option('-n', '--numrhoc', default=2e2, help='number of central densities to sample per EoS, DEFAULT=200', metavar='2e2')
parser.add_option('-r', '--rhorng', default='0.8,1.2e1', help='comma-separated min and max values for central density in units of rhonuc, DEFAULT=0.8,1.2e1', metavar='0.8,1.2e1')
parser.add_option('-m', '--mrng', default=False, help='use mass range instead of central density range, DEFAULT=False', metavar='Mmin,Mmax')
parser.add_option('-s', '--stpi', default=1e-4, help='starting fractional enthalpy step size for TOV integration, DEFAULT=1e-4', metavar='1e-4')
parser.add_option('-N', '--numpts', default=2e3, help='number of enthalpy points for TOV integration, DEFAULT=2e3', metavar='2e3')
parser.add_option('-T', '--tol', default=5e1, help='pressure tolerance for surface finding algorithm in g/cm^3, DEFAULT=5e1', metavar='5e1')
parser.add_option('-d', '--dir', default='./eos/', help='path to directory housing EoS data, DEFAULT=./eos/', metavar='./eos/')
parser.add_option('-o', '--outdir', default='./dat/', help='path to output directory, DEFAULT=./dat/', metavar='./dat/')
parser.add_option('-t', '--tag', default='macro-', help='tag for output data file, DEFAULT=macro-', metavar='macro-')
parser.add_option('-v', '--verbose', action='store_true', default=False, help='toggle verbose output, DEFAULT=False', metavar='False')

opts, args = parser.parse_args()
eosnames = str(args[0]).split(',')
propslist = str(opts.props).split(',')
numprops = len(propslist)
rhorng = str(opts.rhorng).split(',')
rhoi, rhof = [float(rho) for rho in rhorng]
numrhoc = int(float(opts.numrhoc))
if opts.mrng:
	mmin, mmax = [float(m) for m in opts.mrng.split(',')]
stp = float(opts.stpi)
numpts = int(float(opts.numpts))
tol = float(opts.tol)
indir = str(opts.dir)
outdir = str(opts.outdir)
tag = str(opts.tag)
verb = opts.verbose

# CALCULATE NS PROPERTIES FOR EACH EOS

for eosname in eosnames:

	shortname = (os.path.basename(eosname).split('.')[0]).split('eos-')[-1]
	if verb == True: print('Calculate properties of '+str(shortname)+' stars')

	eospath = indir+eosname
	eosdat = np.genfromtxt(eospath,names=True,delimiter=',')
	rhodat = eosdat['baryon_density'] # rest-mass energy density in g/cm^3
	pdat = eosdat['pressurec2'] # pressure in units of g/cm^3
	mudat = eosdat['energy_densityc2'] # total energy density in units of g/cm^3
	
	rhop = interp1d(pdat,rhodat,kind='linear',bounds_error=False,fill_value=0)
	def Rho(p): return rhop(p)
	
	mup = interp1d(pdat,mudat,kind='linear',bounds_error=False,fill_value=0)
	def mu(p): return mup(p)
		
	prho = interp1d(rhodat,pdat,kind='linear',bounds_error=False,fill_value=0)
	def P(rho): return prho(rho)
	
	cs2pi = interp1d(pdat,np.gradient(mudat,pdat),kind='linear', bounds_error=False, fill_value=0)
	def cs2i(p): return cs2pi(p) # 1/sound speed squared
	
	rhocs = np.linspace(max(rhoi*rhonuc,rhodat[0]),min(rhof*rhonuc,rhodat[-1]),numrhoc)
	
	properties = np.zeros((numrhoc,numprops+1))
	props = ['pR']+propslist

	idx = 0
	idxs = {}
	for prop in ['pR','M','R','Lambda','I','Mb']:
		if prop in props:
			idxs[prop] = idx
			idx = idx + 1
	
	if opts.mrng:
		if verb == True: print('Start at mass {0} Msun'.format(mmin))
	else:
		if verb == True: print('Start at central density {0} g/cm^3'.format(rhocs[0]))

	i = int(numrhoc/2) - 1 # start at midpoint in rhoc		
	for rhoc in list(reversed(rhocs[:int(numrhoc/2)])): # compute macroscopic properties for star of each central density
		macro = tov([mu,P,cs2i,Rho],rhoc,props,idxs,stp,numpts,tol)[1:]
		if opts.mrng:
			if macro[0] < mmin: break
		properties[i] = [item for List in [[rhoc],macro] for item in List]
		i = i-1
	
	i = int(numrhoc/2) # continue in other direction from midpoint
	for rhoc in rhocs[int(len(rhocs)/2):]: # compute macroscopic properties for star of each central density
		macro = tov([mu,P,cs2i,Rho],rhoc,props,idxs,stp,numpts,tol)[1:]
		if opts.mrng:
			if macro[0] > mmax: break
		properties[i] = [item for List in [[rhoc],macro] for item in List]
		i = i+1

	if opts.mrng:
		if verb == True: print('Done at mass {0} Msun'.format(mmax))
	else:
		if verb == True: print('Done at central density {0} g/cm^3\nSave to '.format(rhocs[-1])+outdir+tag+shortname+'.csv')

	properties = properties[~np.all(properties == 0, axis=1)] # drop zeroed rows
	np.savetxt(outdir+tag+shortname+".csv", properties, delimiter=',', header='rhoc,'+','.join([prop for prop in ['pR','M','R','Lambda','I','Mb'] if prop in props[1:]]), comments='')
